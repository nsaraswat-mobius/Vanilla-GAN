name: Build Vanilla GAN Model
description: Builds Vanilla GAN model using master config with fully connected architecture
inputs:
  - name: gan_config_json
    type: String
    description: Master GAN configuration as JSON string
  - name: model_name
    type: String
    description: Model name (vanilla_gan)
outputs:
  - name: model_out
    type: Model
  - name: gan_config_base64_updated
    type: String
    description: Updated master GAN configuration (base64 encoded)
  - name: model_info
    type: String

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v36-gpu
    command:
      - sh
      - -c
      - |
        pip install torchvision==0.15.2 --quiet
        echo "Torchvision installed"
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import argparse
        import os
        import sys
        import json
        import pickle
        import base64
        import traceback
        import time
        import importlib.util
        
        parser = argparse.ArgumentParser(description='Vanilla GAN Model Builder')
        parser.add_argument('--gan_config_json', type=str, required=True, help='Master GAN config as JSON string')
        parser.add_argument('--model_name', type=str, required=True, help='Model name (vanilla_gan)')
        parser.add_argument('--model_out', type=str, required=True, help='Output path for model')
        parser.add_argument('--gan_config_base64_updated', type=str, required=True, help='Output path for updated config (base64)')
        parser.add_argument('--model_info', type=str, required=True, help='Output path for model info')
        args = parser.parse_args()
        
        print("VANILLA GAN MODEL BUILDER STARTING")
        print("="*60)
        print(f"gan_config_json length: {len(args.gan_config_json)}")
        print(f"model_name: {args.model_name}")
        
        # Parse JSON config
        try:
            gan_config = json.loads(args.gan_config_json)
            print("Master GAN config parsed successfully")
        except Exception as e:
            print(f"Failed to parse JSON config: {e}")
            traceback.print_exc()
            sys.exit(1)
        
        model_config = gan_config.get('model', {})
        
        # Force model type to vanilla_gan
        model_config['gan_type'] = 'vanilla_gan'
        model_type = 'vanilla_gan'
        print(f"Building {model_type.upper()} model")
        
        # Import torch
        try:
            import torch
            import torch.nn as nn
            import torch.nn.functional as F
            print(f"PyTorch version: {torch.__version__}")
            print(f"CUDA available: {torch.cuda.is_available()}")
        except ImportError as e:
            print(f"Failed to import torch: {e}")
            sys.exit(1)
        
        # Define Vanilla GAN architecture directly
        class VanillaGenerator(nn.Module):
            def __init__(self, latent_dim, output_dim, hidden_layers=[256, 512, 1024]):
                super(VanillaGenerator, self).__init__()
                self.latent_dim = latent_dim
                self.output_dim = output_dim
                
                layers = []
                input_dim = latent_dim
                
                # Hidden layers
                for hidden_dim in hidden_layers:
                    layers.append(nn.Linear(input_dim, hidden_dim))
                    layers.append(nn.ReLU())
                    input_dim = hidden_dim
                
                # Output layer
                layers.append(nn.Linear(input_dim, output_dim))
                layers.append(nn.Tanh())  # Output in range [-1, 1]
                
                self.model = nn.Sequential(*layers)
            
            def forward(self, z):
                return self.model(z)
        
        class VanillaDiscriminator(nn.Module):
            def __init__(self, input_dim, hidden_layers=[1024, 512, 256]):
                super(VanillaDiscriminator, self).__init__()
                self.input_dim = input_dim
                
                layers = []
                current_dim = input_dim
                
                # Hidden layers
                for hidden_dim in hidden_layers:
                    layers.append(nn.Linear(current_dim, hidden_dim))
                    layers.append(nn.LeakyReLU(0.2))
                    layers.append(nn.Dropout(0.3))
                    current_dim = hidden_dim
                
                # Output layer
                layers.append(nn.Linear(current_dim, 1))
                layers.append(nn.Sigmoid())  # Output probability
                
                self.model = nn.Sequential(*layers)
            
            def forward(self, x):
                return self.model(x)
        
        class VanillaGANConfig:
            def __init__(self, input_dim=784, latent_dim=100, generator_layers=[256, 512, 1024], 
                         discriminator_layers=[1024, 512, 256], lr=0.0002, batch_size=64, 
                         epochs=200, device='cpu', **kwargs):
                self.input_dim = input_dim
                self.latent_dim = latent_dim
                self.generator_layers = generator_layers
                self.discriminator_layers = discriminator_layers
                self.lr = lr
                self.batch_size = batch_size
                self.epochs = epochs
                self.device = device
                
                # Additional config items
                for key, value in kwargs.items():
                    setattr(self, key, value)
        
        class VanillaGAN:
            def __init__(self, config):
                self.config = config
                self.device = torch.device(config.device)
                
                # Create models
                self.generator = VanillaGenerator(
                    config.latent_dim, 
                    config.input_dim, 
                    config.generator_layers
                ).to(self.device)
                
                self.discriminator = VanillaDiscriminator(
                    config.input_dim, 
                    config.discriminator_layers
                ).to(self.device)
                
                # Initialize weights
                self._initialize_weights()
                
                # Optimizers
                self.g_optimizer = torch.optim.Adam(
                    self.generator.parameters(), 
                    lr=config.lr, 
                    betas=(0.5, 0.999)
                )
                self.d_optimizer = torch.optim.Adam(
                    self.discriminator.parameters(), 
                    lr=config.lr, 
                    betas=(0.5, 0.999)
                )
                
                # Loss function
                self.criterion = nn.BCELoss()
                
                print(f"Vanilla GAN initialized:")
                print(f"  Generator: {sum(p.numel() for p in self.generator.parameters())} parameters")
                print(f"  Discriminator: {sum(p.numel() for p in self.discriminator.parameters())} parameters")
                print(f"  Device: {self.device}")
            
            def _initialize_weights(self):
                for module in [self.generator, self.discriminator]:
                    for m in module.modules():
                        if isinstance(m, nn.Linear):
                            nn.init.normal_(m.weight.data, 0.0, 0.02)
                            if m.bias is not None:
                                nn.init.constant_(m.bias.data, 0)
            
            def generate_samples(self, num_samples):
                self.generator.eval()
                with torch.no_grad():
                    z = torch.randn(num_samples, self.config.latent_dim, device=self.device)
                    samples = self.generator(z)
                return samples
            
            def get_model_info(self):
                return {
                    'model_type': 'vanilla_gan',
                    'input_dim': self.config.input_dim,
                    'latent_dim': self.config.latent_dim,
                    'generator_layers': self.config.generator_layers,
                    'discriminator_layers': self.config.discriminator_layers,
                    'device': str(self.device),
                    'generator_params': sum(p.numel() for p in self.generator.parameters()),
                    'discriminator_params': sum(p.numel() for p in self.discriminator.parameters())
                }
        
        model = None
        
        # Build Vanilla GAN model
        try:
            print("Creating Vanilla GAN model...")
            
            # Extract configuration from master config
            vanilla_config_dict = {
                'input_dim': model_config.get('input_dim', 784),
                'latent_dim': model_config.get('latent_dim', 100),
                'generator_layers': model_config.get('generator_layers', [256, 512, 1024]),
                'discriminator_layers': model_config.get('discriminator_layers', [1024, 512, 256]),
                'lr': model_config.get('learning_rate', 0.0002),
                'batch_size': model_config.get('batch_size', 64),
                'epochs': model_config.get('epochs', 200),
                'device': 'cuda' if torch.cuda.is_available() else 'cpu',
                'training_algorithm': model_config.get('training_algorithm', 'backprop'),
                'use_wgan': model_config.get('use_wgan', False)
            }
            
            print(f"Vanilla GAN config: {vanilla_config_dict}")
            vanilla_config = VanillaGANConfig(**vanilla_config_dict)
            model = VanillaGAN(vanilla_config)
            
            print("Vanilla GAN model created successfully")
                
        except Exception as e:
            print(f"Failed to create Vanilla GAN model: {e}")
            traceback.print_exc()
            sys.exit(1)
        
        if model is None:
            print("Model creation failed")
            sys.exit(1)
        
        # Test model
        print("Testing Vanilla GAN model...")
        try:
            # Test generator
            z = torch.randn(4, model.config.latent_dim, device=model.device)
            with torch.no_grad():
                samples = model.generator(z)
            print(f"Generator test passed. Output shape: {samples.shape}")
            
            # Test discriminator
            fake_data = torch.randn(4, model.config.input_dim, device=model.device)
            with torch.no_grad():
                pred = model.discriminator(fake_data)
            print(f"Discriminator test passed. Output shape: {pred.shape}")
            
        except Exception as e:
            print(f"Model test failed: {e}")
            traceback.print_exc()
        
        # Update master config with build information
        gan_config['model'].update({
            'model_built': True,
            'model_class': 'VanillaGAN',
            'architecture': 'fully_connected',
            'latent_dim': model.config.latent_dim,
            'input_dim': model.config.input_dim,
            'generator_layers': model.config.generator_layers,
            'discriminator_layers': model.config.discriminator_layers,
            'generator_params': sum(p.numel() for p in model.generator.parameters()),
            'discriminator_params': sum(p.numel() for p in model.discriminator.parameters()),
            'built_timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'device': str(model.device)
        })
        
        gan_config['metadata'].update({
            'built_at': time.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'build_step': 'completed',
            'model_created': True,
            'model_type': 'vanilla_gan',
            'architecture_type': 'fully_connected'
        })
        
        # Create detailed model info
        model_info_data = {
            'model_type': 'vanilla_gan',
            'model_name': args.model_name,
            'build_status': 'success',
            'model_class': 'VanillaGAN',
            'architecture': 'fully_connected',
            'latent_dim': model.config.latent_dim,
            'input_dim': model.config.input_dim,
            'generator_layers': model.config.generator_layers,
            'discriminator_layers': model.config.discriminator_layers,
            'total_parameters': {
                'generator': sum(p.numel() for p in model.generator.parameters()),
                'discriminator': sum(p.numel() for p in model.discriminator.parameters()),
                'total': sum(p.numel() for p in model.generator.parameters()) + sum(p.numel() for p in model.discriminator.parameters())
            },
            'config': vanilla_config_dict,
            'pytorch_version': torch.__version__,
            'cuda_available': torch.cuda.is_available(),
            'device': str(model.device),
            'build_timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'data_format': 'flattened_vectors'
        }
        
        # Encode updated config to base64
        updated_config_json = json.dumps(gan_config, indent=2)
        updated_config_base64 = base64.b64encode(updated_config_json.encode('utf-8')).decode('utf-8')
        
        # Save outputs with better error handling
        print("Saving model outputs...")
        
        # Save model
        os.makedirs(os.path.dirname(args.model_out) or '.', exist_ok=True)
        try:
            # Create a simplified model wrapper for reliable pickling
            class VanillaGANWrapper:
                def __init__(self, model_obj):
                    self.model_type = 'vanilla_gan'
                    self.config = model_obj.config.__dict__
                    self.generator_state = model_obj.generator.state_dict()
                    self.discriminator_state = model_obj.discriminator.state_dict()
                    self.generator_arch = model_obj.generator
                    self.discriminator_arch = model_obj.discriminator
                    self.device = str(model_obj.device)
                    self.model_info = model_obj.get_model_info()
            
            wrapper = VanillaGANWrapper(model)
            with open(args.model_out, 'wb') as f:
                pickle.dump(wrapper, f, protocol=pickle.HIGHEST_PROTOCOL)
            print(f"Model saved successfully: {args.model_out}")
            
        except Exception as e:
            print(f"Failed to save full model, saving state dict: {e}")
            # Fallback: save only state dicts and config
            model_state = {
                'model_type': 'vanilla_gan',
                'config': vanilla_config_dict,
                'generator_state_dict': model.generator.state_dict(),
                'discriminator_state_dict': model.discriminator.state_dict(),
                'model_info': model.get_model_info()
            }
            with open(args.model_out, 'wb') as f:
                pickle.dump(model_state, f, protocol=pickle.HIGHEST_PROTOCOL)
            print(f"Model state saved: {args.model_out}")
        
        # Save updated config
        os.makedirs(os.path.dirname(args.gan_config_base64_updated) or '.', exist_ok=True)
        with open(args.gan_config_base64_updated, 'w') as f:
            f.write(updated_config_base64)
        
        # Save model info
        os.makedirs(os.path.dirname(args.model_info) or '.', exist_ok=True)
        with open(args.model_info, 'w') as f:
            json.dump(model_info_data, f, indent=2)
        
        print("="*60)
        print("Vanilla GAN Build completed successfully")
        print(f"Model saved: {args.model_out}")
        print(f"Config (base64) saved: {args.gan_config_base64_updated}")
        print(f"Model info saved: {args.model_info}")
        print(f"Generator parameters: {sum(p.numel() for p in model.generator.parameters()):,}")
        print(f"Discriminator parameters: {sum(p.numel() for p in model.discriminator.parameters()):,}")
        print(f"Device: {model.device}")
        print("="*60)

    args:
      - --gan_config_json
      - {inputValue: gan_config_json}
      - --model_name
      - {inputValue: model_name}
      - --model_out
      - {outputPath: model_out}
      - --gan_config_base64_updated
      - {outputPath: gan_config_base64_updated}
      - --model_info
      - {outputPath: model_info}
