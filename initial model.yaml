name: Initialize Vanilla GAN Model
description: Initializes Vanilla GAN model with multiple training algorithm support for UI component generation.
inputs:
  - name: gan_config
    type: String
    description: "Vanilla GAN configuration from preprocessing step"
outputs:
  - name: model
    type: Model
  - name: init_config
    type: String
    description: "Initialization configuration"

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v33
    command:
      - sh
      - -c
      - |
        # Install torchvision compatible with nesy-factory requirements
        # nesy-factory 1.0.0 requires torch<2.3.0,>=2.0.0
        # So we install torchvision 0.15.2 which is compatible with torch 2.0.0-2.2.0
        pip install torchvision==0.15.2 --no-deps --quiet
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import sys, os, pickle, json, torch, argparse
        
        parser = argparse.ArgumentParser()
        parser.add_argument('--gan_config', type=str, required=True)
        parser.add_argument('--model_path', type=str, required=True)
        parser.add_argument('--init_config_path', type=str, required=True)
        args = parser.parse_args()
        
        print('Starting Vanilla GAN Model Initialization')
        
        # Parse Vanilla GAN configuration
        gan_config_str = args.gan_config
        print(f'Vanilla GAN config received, length: {len(gan_config_str)}')
        print(f'Config preview: {gan_config_str[:100]}...')
        
        try:
            gan_config = json.loads(gan_config_str)
            print('Direct JSON parse successful')
        except json.JSONDecodeError as e:
            print(f'JSON parse error: {e}')
            try:
                cleaned = gan_config_str.strip()
                if cleaned.startswith('"') and cleaned.endswith('"'):
                    cleaned = cleaned[1:-1]
                cleaned = cleaned.replace('\\"', '"').replace('\\\\"', '"')
                gan_config = json.loads(cleaned)
                print('Parsed after cleaning')
            except Exception as e2:
                print(f'Failed to parse config after cleaning: {e2}')
                raise ValueError("Invalid JSON configuration")
        
        # Verify or set model type for Vanilla GAN
        model_type = gan_config.get('model_type', '').lower()
        if not model_type:
            # If model_type is missing, assume vanilla_gan since this is the vanilla GAN initializer
            model_type = 'vanilla_gan'
            gan_config['model_type'] = 'vanilla_gan'
            print('Model type not specified, defaulting to vanilla_gan')
        elif model_type != 'vanilla_gan':
            print(f'Warning: Expected vanilla_gan model type, got: {model_type}. Proceeding with vanilla_gan.')
            model_type = 'vanilla_gan'
            gan_config['model_type'] = 'vanilla_gan'
        
        print('VANILLA GAN Configuration:')
        print(f'  Input Dimension: {gan_config.get("input_dim", 784)}')
        print(f'  Latent Dimension: {gan_config.get("latent_dim", 100)}')
        print(f'  Image Size: {gan_config.get("image_size", 64)}')
        print(f'  Channels: {gan_config.get("channels", 3)}')
        print(f'  Training Algorithm: {gan_config.get("training_algorithm", "backprop")}')
        print(f'  Generator Layers: {gan_config.get("generator_layers", [256, 512, 1024])}')
        print(f'  Discriminator Layers: {gan_config.get("discriminator_layers", [1024, 512, 256])}')
        
        # Import Vanilla GAN from nesy-factory Docker container
        print('Importing VanillaGAN from nesy-factory...')
        try:
            # First create minimal registry to satisfy any registry dependencies
            import sys
            
            # Create a minimal registry if it doesn't exist
            try:
                from nesy_factory.GANs.registry import register_gan_model, get_gan_model, list_gan_models
                print('Registry imported from nesy-factory')
            except ImportError:
                print('Creating minimal registry for compatibility')
                class MinimalRegistry:
                    _models = {}
                    @classmethod
                    def register_gan_model(cls, name, model_class):
                        cls._models[name] = model_class
                    @classmethod
                    def get_gan_model(cls, name):
                        return cls._models.get(name)
                    @classmethod
                    def list_gan_models(cls):
                        return list(cls._models.keys())
                
                # Add to sys.modules
                if 'nesy_factory' not in sys.modules:
                    sys.modules['nesy_factory'] = type(sys)('nesy_factory')
                if 'nesy_factory.GANs' not in sys.modules:
                    sys.modules['nesy_factory.GANs'] = type(sys)('GANs')
                
                registry_module = type(sys)('registry')
                for attr in ['register_gan_model', 'get_gan_model', 'list_gan_models']:
                    setattr(registry_module, attr, getattr(MinimalRegistry, attr))
                sys.modules['nesy_factory.GANs.registry'] = registry_module
            
            # Now import VanillaGAN from nesy-factory
            from nesy_factory.GANs.vanilla_gan import VanillaGAN, VanillaGANConfig, TrainingAlgorithm
            print('VanillaGAN imported successfully from nesy-factory')
            
        except ImportError as import_error:
            print(f'Failed to import from nesy-factory: {import_error}')
            
            # Fallback: Try to find VanillaGAN in the Docker container's Python path
            print('Searching for VanillaGAN in Docker container...')
            import importlib.util
            import glob
            
            # Search for vanilla_gan.py in common Docker container locations
            search_paths = [
                '/usr/local/lib/python*/site-packages/nesy_factory/GANs/vanilla_gan.py',
                '/opt/conda/lib/python*/site-packages/nesy_factory/GANs/vanilla_gan.py',
                '/usr/lib/python*/site-packages/nesy_factory/GANs/vanilla_gan.py',
                '/app/nesy_factory/GANs/vanilla_gan.py',
                '/workspace/nesy_factory/GANs/vanilla_gan.py'
            ]
            
            vanilla_gan_found = False
            for pattern in search_paths:
                matching_files = glob.glob(pattern)
                for vanilla_gan_path in matching_files:
                    try:
                        print(f'Trying to load VanillaGAN from: {vanilla_gan_path}')
                        spec = importlib.util.spec_from_file_location("vanilla_gan_module", vanilla_gan_path)
                        if spec and spec.loader:
                            vanilla_gan_module = importlib.util.module_from_spec(spec)
                            spec.loader.exec_module(vanilla_gan_module)
                            
                            if hasattr(vanilla_gan_module, 'VanillaGAN'):
                                VanillaGAN = vanilla_gan_module.VanillaGAN
                                VanillaGANConfig = vanilla_gan_module.VanillaGANConfig
                                TrainingAlgorithm = getattr(vanilla_gan_module, 'TrainingAlgorithm', None)
                                print(f'VanillaGAN loaded successfully from: {vanilla_gan_path}')
                                vanilla_gan_found = True
                                break
                    except Exception as e:
                        print(f'Failed to load from {vanilla_gan_path}: {e}')
                        continue
                
                if vanilla_gan_found:
                    break
            
            if not vanilla_gan_found:
                raise ImportError('VanillaGAN not found in nesy-factory Docker container')
        
        print('Creating Vanilla GAN model...')
        
        # Build configuration for Vanilla GAN
        vanilla_config_dict = {
            # Basic GAN parameters
            'input_dim': gan_config.get('input_dim', 784),
            'latent_dim': gan_config.get('latent_dim', 100),
            'batch_size': gan_config.get('batch_size', 32),
            'epochs': gan_config.get('epochs', 100),
            'lr': gan_config.get('learning_rate', 0.0002),
            'beta1': gan_config.get('beta1', 0.5),
            'beta2': gan_config.get('beta2', 0.999),
            
            # Network architecture
            'generator_layers': gan_config.get('generator_layers', [256, 512, 1024]),
            'discriminator_layers': gan_config.get('discriminator_layers', [1024, 512, 256]),
            'generator_activation': gan_config.get('generator_activation', 'relu'),
            'discriminator_activation': gan_config.get('discriminator_activation', 'leaky_relu'),
            'output_activation': gan_config.get('output_activation', 'tanh'),
            'generator_dropout': gan_config.get('generator_dropout', 0.0),
            'discriminator_dropout': gan_config.get('discriminator_dropout', 0.3),
            
            # Training algorithm
            'training_algorithm': gan_config.get('training_algorithm', 'backprop'),
            'use_forward_forward': gan_config.get('training_algorithm', '').lower() == 'forward_forward',
            'use_cafo': gan_config.get('training_algorithm', '').lower() == 'cafo',
            
            # Forward-Forward parameters
            'ff_blocks': gan_config.get('ff_blocks', 3),
            'ff_epochs_per_block': gan_config.get('ff_epochs_per_block', 50),
            'ff_theta': gan_config.get('ff_theta', 2.0),
            'ff_positive_margin': gan_config.get('ff_positive_margin', 2.0),
            'ff_negative_margin': gan_config.get('ff_negative_margin', 0.0),
            
            # CAFO parameters
            'cafo_blocks': gan_config.get('cafo_blocks', 3),
            'epochs_per_block': gan_config.get('epochs_per_block', 30),
            'block_lr': gan_config.get('block_lr', 0.001),
            
            # Training parameters
            'device': 'cuda' if torch.cuda.is_available() else 'cpu',
            'sample_interval': gan_config.get('sample_interval', 100),
            'save_interval': gan_config.get('save_interval', 500),
            'log_interval': gan_config.get('log_interval', 10)
        }
        
        print(f'Vanilla GAN config dict: {vanilla_config_dict}')
        
        # Create Vanilla GAN model
        try:
            vanilla_config = VanillaGANConfig(**vanilla_config_dict)
            print('VanillaGANConfig created successfully')
            
            # Validate configuration if method exists
            try:
                is_valid, warnings = vanilla_config.validate()
                if not is_valid:
                    print(f'Configuration validation warnings: {warnings}')
            except AttributeError:
                print('Validation method not available, proceeding...')
            
            vanilla_gan_model = VanillaGAN(vanilla_config)
            print('Vanilla GAN model created successfully')
            
            print('Model Summary:')
            print(f'  Generator: {type(vanilla_gan_model.generator).__name__}')
            print(f'  Discriminator: {type(vanilla_gan_model.discriminator).__name__}')
            if hasattr(vanilla_gan_model, 'trainer'):
                print(f'  Trainer: {type(vanilla_gan_model.trainer).__name__}')
                if hasattr(vanilla_gan_model.trainer, 'device'):
                    print(f'  Device: {vanilla_gan_model.trainer.device}')
            else:
                print(f'  Device: {vanilla_config_dict.get("device", "cpu")}')
            
        except Exception as e:
            print(f'Error creating Vanilla GAN: {e}')
            import traceback
            traceback.print_exc()
            raise
        
        if vanilla_gan_model is None:
            raise RuntimeError("Failed to create Vanilla GAN model")
        
        # Save model
        output_dir = os.path.dirname(args.model_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        
        with open(args.model_path, 'wb') as f:
            pickle.dump(vanilla_gan_model, f)
        print(f'Model saved to: {args.model_path}')
        
        # Save initialization config
        init_config = {
            'model_created': True,
            'model_type': 'vanilla_gan',
            'success': True,
            'device': 'cuda' if torch.cuda.is_available() else 'cpu',
            'input_dim': vanilla_config_dict['input_dim'],
            'latent_dim': vanilla_config_dict['latent_dim'],
            'training_algorithm': vanilla_config_dict['training_algorithm'],
            'generator_layers': vanilla_config_dict['generator_layers'],
            'discriminator_layers': vanilla_config_dict['discriminator_layers'],
            'num_classes': gan_config.get('num_classes', 2),
            'class_names': gan_config.get('class_names', ['inputfield', 'toggle']),
            'dataset_type': gan_config.get('dataset_type', 'ui_components'),
            'original_config': gan_config,
            'model_summary': {
                'generator_class': type(vanilla_gan_model.generator).__name__,
                'discriminator_class': type(vanilla_gan_model.discriminator).__name__,
                'trainer_class': type(vanilla_gan_model.trainer).__name__ if hasattr(vanilla_gan_model, 'trainer') else 'SimpleTrainer'
            }
        }
        
        output_dir_config = os.path.dirname(args.init_config_path)
        if output_dir_config and not os.path.exists(output_dir_config):
            os.makedirs(output_dir_config, exist_ok=True)
        
        with open(args.init_config_path, 'w') as f:
            json.dump(init_config, f, indent=2)
        print(f'Init config saved to: {args.init_config_path}')
        
        print('VANILLA GAN Model Initialization Complete')
        print(f'Model type: vanilla_gan')
        print(f'Model class: {type(vanilla_gan_model).__name__}')
        print(f'Training algorithm: {vanilla_config_dict["training_algorithm"]}')
        print(f'Input dimension: {vanilla_config_dict["input_dim"]}')
        print(f'Model created successfully')

    args:
      - --gan_config
      - {inputValue: gan_config}
      - --model_path
      - {outputPath: model}
      - --init_config_path
      - {outputPath: init_config}
