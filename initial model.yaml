name: Initialize Vanilla GAN Model
description: Initializes Vanilla GAN model with multiple training algorithm support for UI component generation.
inputs:
  - name: gan_config
    type: String
    description: "Vanilla GAN configuration from preprocessing step"
outputs:
  - name: model
    type: Model
  - name: init_config
    type: String
    description: "Initialization configuration"

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v33
    command:
      - sh
      - -c
      - |
        # Install torchvision compatible with nesy-factory requirements
        # nesy-factory 1.0.0 requires torch<2.3.0,>=2.0.0
        # So we install torchvision 0.15.2 which is compatible with torch 2.0.0-2.2.0
        pip install torchvision==0.15.2 --no-deps --quiet
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import sys, os, pickle, json, torch, argparse
        
        parser = argparse.ArgumentParser()
        parser.add_argument('--gan_config', type=str, required=True)
        parser.add_argument('--model_path', type=str, required=True)
        parser.add_argument('--init_config_path', type=str, required=True)
        args = parser.parse_args()
        
        print('Starting Vanilla GAN Model Initialization')
        
        # Parse Vanilla GAN configuration
        gan_config_str = args.gan_config
        print(f'Vanilla GAN config received, length: {len(gan_config_str)}')
        print(f'Config preview: {gan_config_str[:100]}...')
        
        try:
            gan_config = json.loads(gan_config_str)
            print('Direct JSON parse successful')
        except json.JSONDecodeError as e:
            print(f'JSON parse error: {e}')
            try:
                cleaned = gan_config_str.strip()
                if cleaned.startswith('"') and cleaned.endswith('"'):
                    cleaned = cleaned[1:-1]
                cleaned = cleaned.replace('\\"', '"').replace('\\\\"', '"')
                gan_config = json.loads(cleaned)
                print('Parsed after cleaning')
            except Exception as e2:
                print(f'Failed to parse config after cleaning: {e2}')
                raise ValueError("Invalid JSON configuration")
        
        # Verify or set model type for Vanilla GAN
        model_type = gan_config.get('model_type', '').lower()
        if not model_type:
            # If model_type is missing, assume vanilla_gan since this is the vanilla GAN initializer
            model_type = 'vanilla_gan'
            gan_config['model_type'] = 'vanilla_gan'
            print('Model type not specified, defaulting to vanilla_gan')
        elif model_type != 'vanilla_gan':
            print(f'Warning: Expected vanilla_gan model type, got: {model_type}. Proceeding with vanilla_gan.')
            model_type = 'vanilla_gan'
            gan_config['model_type'] = 'vanilla_gan'
        
        print('VANILLA GAN Configuration:')
        print(f'  Input Dimension: {gan_config.get("input_dim", 784)}')
        print(f'  Latent Dimension: {gan_config.get("latent_dim", 100)}')
        print(f'  Image Size: {gan_config.get("image_size", 64)}')
        print(f'  Channels: {gan_config.get("channels", 3)}')
        print(f'  Training Algorithm: {gan_config.get("training_algorithm", "backprop")}')
        print(f'  Generator Layers: {gan_config.get("generator_layers", [256, 512, 1024])}')
        print(f'  Discriminator Layers: {gan_config.get("discriminator_layers", [1024, 512, 256])}')
        
        # Import Vanilla GAN
        print('Importing VanillaGAN...')
        try:
            from nesy_factory.GANs.vanilla_gan import VanillaGAN, VanillaGANConfig, TrainingAlgorithm
            print('VanillaGAN imported successfully')
        except ImportError as e:
            print(f'VanillaGAN import error: {e}')
            print('Attempting to load from current directory...')
            try:
                # Fallback: try to load from local file with multiple paths
                import importlib.util
                possible_paths = [
                    "/workspace/src/nesy_factory/GANs/vanilla_gan.py",
                    "vanilla_gan.py",
                    "../vanilla_gan.py",
                    "/app/src/nesy_factory/GANs/vanilla_gan.py"
                ]
                
                vanilla_gan_module = None
                for path in possible_paths:
                    try:
                        if os.path.exists(path):
                            spec = importlib.util.spec_from_file_location("vanilla_gan", path)
                            if spec and spec.loader:
                                vanilla_gan_module = importlib.util.module_from_spec(spec)
                                spec.loader.exec_module(vanilla_gan_module)
                                print(f'VanillaGAN loaded from: {path}')
                                break
                    except Exception as pe:
                        print(f'Failed to load from {path}: {pe}')
                        continue
                
                if vanilla_gan_module:
                    VanillaGAN = vanilla_gan_module.VanillaGAN
                    VanillaGANConfig = vanilla_gan_module.VanillaGANConfig
                    TrainingAlgorithm = getattr(vanilla_gan_module, 'TrainingAlgorithm', None)
                    print('VanillaGAN loaded from local file')
                else:
                    raise ImportError("Could not load VanillaGAN from any path")
            except Exception as e2:
                print(f'Local load failed: {e2}')
                # Last resort: create minimal vanilla GAN implementation
                print('Creating minimal VanillaGAN implementation...')
                try:
                    import torch.nn as nn
                    
                    class SimpleVanillaGANConfig:
                        def __init__(self, **kwargs):
                            for key, value in kwargs.items():
                                setattr(self, key, value)
                        
                        def validate(self):
                            return True, []
                    
                    class SimpleGenerator(nn.Module):
                        def __init__(self, latent_dim, output_dim, hidden_layers):
                            super().__init__()
                            layers = []
                            prev_dim = latent_dim
                            for hidden_dim in hidden_layers:
                                layers.extend([
                                    nn.Linear(prev_dim, hidden_dim),
                                    nn.ReLU()
                                ])
                                prev_dim = hidden_dim
                            layers.append(nn.Linear(prev_dim, output_dim))
                            layers.append(nn.Tanh())
                            self.model = nn.Sequential(*layers)
                        
                        def forward(self, z):
                            return self.model(z)
                    
                    class SimpleDiscriminator(nn.Module):
                        def __init__(self, input_dim, hidden_layers):
                            super().__init__()
                            layers = []
                            prev_dim = input_dim
                            for hidden_dim in hidden_layers:
                                layers.extend([
                                    nn.Linear(prev_dim, hidden_dim),
                                    nn.LeakyReLU(0.2)
                                ])
                                prev_dim = hidden_dim
                            layers.append(nn.Linear(prev_dim, 1))
                            layers.append(nn.Sigmoid())
                            self.model = nn.Sequential(*layers)
                        
                        def forward(self, x):
                            return self.model(x)
                    
                    class SimpleVanillaGAN:
                        def __init__(self, config):
                            self.config = config
                            self.generator = SimpleGenerator(
                                config.latent_dim,
                                config.input_dim,
                                config.generator_layers
                            )
                            self.discriminator = SimpleDiscriminator(
                                config.input_dim,
                                config.discriminator_layers
                            )
                            
                            # Create a simple trainer object
                            class SimpleTrainer:
                                def __init__(self, device):
                                    self.device = device
                            
                            self.trainer = SimpleTrainer(config.device)
                    
                    VanillaGAN = SimpleVanillaGAN
                    VanillaGANConfig = SimpleVanillaGANConfig
                    TrainingAlgorithm = None
                    print('Minimal VanillaGAN implementation created')
                except Exception as e3:
                    print(f'Failed to create minimal implementation: {e3}')
                    raise ImportError("VanillaGAN not available and cannot create fallback")
        
        print('Creating Vanilla GAN model...')
        
        # Build configuration for Vanilla GAN
        vanilla_config_dict = {
            # Basic GAN parameters
            'input_dim': gan_config.get('input_dim', 784),
            'latent_dim': gan_config.get('latent_dim', 100),
            'batch_size': gan_config.get('batch_size', 32),
            'epochs': gan_config.get('epochs', 100),
            'lr': gan_config.get('learning_rate', 0.0002),
            'beta1': gan_config.get('beta1', 0.5),
            'beta2': gan_config.get('beta2', 0.999),
            
            # Network architecture
            'generator_layers': gan_config.get('generator_layers', [256, 512, 1024]),
            'discriminator_layers': gan_config.get('discriminator_layers', [1024, 512, 256]),
            'generator_activation': gan_config.get('generator_activation', 'relu'),
            'discriminator_activation': gan_config.get('discriminator_activation', 'leaky_relu'),
            'output_activation': gan_config.get('output_activation', 'tanh'),
            'generator_dropout': gan_config.get('generator_dropout', 0.0),
            'discriminator_dropout': gan_config.get('discriminator_dropout', 0.3),
            
            # Training algorithm
            'training_algorithm': gan_config.get('training_algorithm', 'backprop'),
            'use_forward_forward': gan_config.get('training_algorithm', '').lower() == 'forward_forward',
            'use_cafo': gan_config.get('training_algorithm', '').lower() == 'cafo',
            
            # Forward-Forward parameters
            'ff_blocks': gan_config.get('ff_blocks', 3),
            'ff_epochs_per_block': gan_config.get('ff_epochs_per_block', 50),
            'ff_theta': gan_config.get('ff_theta', 2.0),
            'ff_positive_margin': gan_config.get('ff_positive_margin', 2.0),
            'ff_negative_margin': gan_config.get('ff_negative_margin', 0.0),
            
            # CAFO parameters
            'cafo_blocks': gan_config.get('cafo_blocks', 3),
            'epochs_per_block': gan_config.get('epochs_per_block', 30),
            'block_lr': gan_config.get('block_lr', 0.001),
            
            # Training parameters
            'device': 'cuda' if torch.cuda.is_available() else 'cpu',
            'sample_interval': gan_config.get('sample_interval', 100),
            'save_interval': gan_config.get('save_interval', 500),
            'log_interval': gan_config.get('log_interval', 10)
        }
        
        print(f'Vanilla GAN config dict: {vanilla_config_dict}')
        
        # Create Vanilla GAN model
        try:
            vanilla_config = VanillaGANConfig(**vanilla_config_dict)
            print('VanillaGANConfig created successfully')
            
            # Validate configuration if method exists
            try:
                is_valid, warnings = vanilla_config.validate()
                if not is_valid:
                    print(f'Configuration validation warnings: {warnings}')
            except AttributeError:
                print('Validation method not available, proceeding...')
            
            vanilla_gan_model = VanillaGAN(vanilla_config)
            print('Vanilla GAN model created successfully')
            
            print('Model Summary:')
            print(f'  Generator: {type(vanilla_gan_model.generator).__name__}')
            print(f'  Discriminator: {type(vanilla_gan_model.discriminator).__name__}')
            if hasattr(vanilla_gan_model, 'trainer'):
                print(f'  Trainer: {type(vanilla_gan_model.trainer).__name__}')
                if hasattr(vanilla_gan_model.trainer, 'device'):
                    print(f'  Device: {vanilla_gan_model.trainer.device}')
            else:
                print(f'  Device: {vanilla_config_dict.get("device", "cpu")}')
            
        except Exception as e:
            print(f'Error creating Vanilla GAN: {e}')
            import traceback
            traceback.print_exc()
            raise
        
        if vanilla_gan_model is None:
            raise RuntimeError("Failed to create Vanilla GAN model")
        
        # Save model
        output_dir = os.path.dirname(args.model_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        
        with open(args.model_path, 'wb') as f:
            pickle.dump(vanilla_gan_model, f)
        print(f'Model saved to: {args.model_path}')
        
        # Save initialization config
        init_config = {
            'model_created': True,
            'model_type': 'vanilla_gan',
            'success': True,
            'device': 'cuda' if torch.cuda.is_available() else 'cpu',
            'input_dim': vanilla_config_dict['input_dim'],
            'latent_dim': vanilla_config_dict['latent_dim'],
            'training_algorithm': vanilla_config_dict['training_algorithm'],
            'generator_layers': vanilla_config_dict['generator_layers'],
            'discriminator_layers': vanilla_config_dict['discriminator_layers'],
            'num_classes': gan_config.get('num_classes', 2),
            'class_names': gan_config.get('class_names', ['inputfield', 'toggle']),
            'dataset_type': gan_config.get('dataset_type', 'ui_components'),
            'original_config': gan_config,
            'model_summary': {
                'generator_class': type(vanilla_gan_model.generator).__name__,
                'discriminator_class': type(vanilla_gan_model.discriminator).__name__,
                'trainer_class': type(vanilla_gan_model.trainer).__name__ if hasattr(vanilla_gan_model, 'trainer') else 'SimpleTrainer'
            }
        }
        
        output_dir_config = os.path.dirname(args.init_config_path)
        if output_dir_config and not os.path.exists(output_dir_config):
            os.makedirs(output_dir_config, exist_ok=True)
        
        with open(args.init_config_path, 'w') as f:
            json.dump(init_config, f, indent=2)
        print(f'Init config saved to: {args.init_config_path}')
        
        print('VANILLA GAN Model Initialization Complete')
        print(f'Model type: vanilla_gan')
        print(f'Model class: {type(vanilla_gan_model).__name__}')
        print(f'Training algorithm: {vanilla_config_dict["training_algorithm"]}')
        print(f'Input dimension: {vanilla_config_dict["input_dim"]}')
        print(f'Model created successfully')

    args:
      - --gan_config
      - {inputValue: gan_config}
      - --model_path
      - {outputPath: model}
      - --init_config_path
      - {outputPath: init_config}
