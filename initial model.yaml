name: Build
description: Builds GAN model using master config
inputs:
  - name: gan_config_base64
    type: String
    description: Master GAN configuration 
  - name: model_name
    type: String
    description: Model name 
outputs:
  - name: model_out
    type: Model
  - name: gan_config_base64_updated
    type: String
    description: Updated master GAN configuration 
  - name: model_info
    type: String

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v34
    command:
      - sh
      - -c
      - |
        pip install torchvision==0.15.2 --quiet
        echo "Torchvision installed"
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import argparse
        import os
        import json
        import pickle
        import base64
        import traceback
        import sys
        
        parser = argparse.ArgumentParser(description='GAN Model Builder')
        parser.add_argument('--gan_config_base64', type=str, required=True, help='Master GAN config (base64)')
        parser.add_argument('--model_name', type=str, required=True, help='Model name (dcgan or vanilla_gan)')
        parser.add_argument('--model_out', type=str, required=True, help='Output path for model')
        parser.add_argument('--gan_config_base64_updated', type=str, required=True, help='Output path for updated config (base64)')
        parser.add_argument('--model_info', type=str, required=True, help='Output path for model info')
        args = parser.parse_args()
        
        print("GAN MODEL BUILDER STARTING")
        print("="*60)
        print(f"gan_config_base64 length: {len(args.gan_config_base64)}")
        print(f"model_name: {args.model_name}")
        
        # Decode base64 config
        try:
            config_json = base64.b64decode(args.gan_config_base64).decode('utf-8')
            gan_config = json.loads(config_json)
            print("Master GAN config decoded successfully")
        except Exception as e:
            print(f"Failed to decode base64 config: {e}")
            sys.exit(1)
        
        model_config = gan_config.get('model', {})
        
        # Override model type if specified
        if args.model_name.lower() in ['dcgan', 'vanilla_gan']:
            model_config['gan_type'] = args.model_name.lower()
        
        model_type = model_config.get('gan_type', 'dcgan')
        print(f"Building {model_type.upper()} model")
        
        # Import torch
        try:
            import torch
            print(f"PyTorch version: {torch.__version__}")
            print(f"CUDA available: {torch.cuda.is_available()}")
        except ImportError as e:
            print(f"Failed to import torch: {e}")
            sys.exit(1)
        
        model = None
        
        try:
            if model_type == 'dcgan':
                from nesy_factory.GANs.dcgan import DCGAN, DCGANConfig
                
                dcgan_config_dict = {
                    'image_size': model_config.get('image_size', 64),
                    'channels': model_config.get('channels', 3),
                    'latent_dim': model_config.get('latent_dim', 100),
                    'training_algorithm': model_config.get('training_algorithm', 'backprop'),
                    'batch_size': model_config.get('batch_size', 32),
                    'learning_rate': model_config.get('learning_rate', 0.0002),
                    'epochs': model_config.get('epochs', 50),
                    'device': 'cuda' if torch.cuda.is_available() else 'cpu',
                }
                
                print(f"DCGAN config created")
                dcgan_config = DCGANConfig(**dcgan_config_dict)
                model = DCGAN(dcgan_config)
                print("DCGAN created successfully")
                
            elif model_type == 'vanilla_gan':
                from nesy_factory.GANs.vanilla_gan import VanillaGAN, VanillaGANConfig
                
                vanilla_config_dict = {
                    'input_dim': model_config.get('input_dim', 784),
                    'latent_dim': model_config.get('latent_dim', 100),
                    'training_algorithm': model_config.get('training_algorithm', 'backprop'),
                    'generator_layers': model_config.get('generator_layers', [256, 512, 1024]),
                    'discriminator_layers': model_config.get('discriminator_layers', [1024, 512, 256]),
                    'generator_activation': model_config.get('generator_activation', 'relu'),
                    'discriminator_activation': model_config.get('discriminator_activation', 'leaky_relu'),
                    'output_activation': model_config.get('output_activation', 'tanh'),
                    'generator_dropout': model_config.get('generator_dropout', 0.0),
                    'discriminator_dropout': model_config.get('discriminator_dropout', 0.3),
                    'batch_size': model_config.get('batch_size', 64),
                    'lr': model_config.get('learning_rate', 0.0002),
                    'beta1': model_config.get('beta1', 0.5),
                    'beta2': model_config.get('beta2', 0.999),
                    'epochs': model_config.get('epochs', 100),
                    'ff_blocks': model_config.get('ff_blocks', 3),
                    'ff_epochs_per_block': model_config.get('ff_epochs_per_block', 100),
                    'ff_theta': model_config.get('ff_theta', 2.0),
                    'ff_positive_margin': model_config.get('ff_positive_margin', 2.0),
                    'ff_negative_margin': model_config.get('ff_negative_margin', 0.0),
                    'cafo_blocks': model_config.get('cafo_blocks', 3),
                    'epochs_per_block': model_config.get('epochs_per_block', 50),
                    'block_lr': model_config.get('block_lr', 0.001),
                    'device': 'cuda' if torch.cuda.is_available() else 'cpu',
                    'sample_interval': model_config.get('sample_interval', 1000),
                    'save_interval': model_config.get('save_interval', 10000),
                    'log_interval': model_config.get('log_interval', 100),
                }
                
                print(f"VanillaGAN config created with parameters:")
                for key, value in vanilla_config_dict.items():
                    print(f"  {key}: {value}")
                
                vanilla_config = VanillaGANConfig(**vanilla_config_dict)
                
                # Validate configuration
                is_valid, warnings = vanilla_config.validate()
                if not is_valid:
                    print(f"Configuration validation failed: {warnings}")
                    sys.exit(1)
                if warnings:
                    print(f"Configuration warnings: {warnings}")
                
                model = VanillaGAN(vanilla_config)
                print("VanillaGAN created successfully")
                print(f"Training algorithm: {vanilla_config.training_algorithm.value}")
                print(f"Generator: {type(model.generator).__name__}")
                print(f"Discriminator: {type(model.discriminator).__name__}")
                print(f"Trainer: {type(model.trainer).__name__}")
                
        except Exception as e:
            print(f"Failed to create model: {e}")
            traceback.print_exc()
            sys.exit(1)
        
        if model is None:
            print("Model creation failed")
            sys.exit(1)
        
        # Test model
        print("Testing model...")
        try:
            if model_type == 'dcgan':
                z = torch.randn(2, model_config.get('latent_dim', 100), 1, 1)
            else:
                # VanillaGAN uses 2D latent vectors (batch_size, latent_dim)
                z = torch.randn(2, model_config.get('latent_dim', 100))
            
            if hasattr(model, 'generator'):
                with torch.no_grad():
                    samples = model.generator(z)
                print(f"Generator test passed. Output shape: {samples.shape}")
                
                # Additional test for VanillaGAN discriminator
                if model_type == 'vanilla_gan':
                    with torch.no_grad():
                        disc_pred = model.discriminator(samples)
                    print(f"Discriminator test passed. Output shape: {disc_pred.shape}")
        except Exception as e:
            print(f"Model test warning: {e}")
            traceback.print_exc()
        
        # Update master config
        import time
        gan_config['model'].update({
            'model_built': True,
            'model_class': type(model).__name__,
            'latent_dim': model_config.get('latent_dim', 100),
            'model_type': model_type
        })
        
        # Add VanillaGAN specific info to config
        if model_type == 'vanilla_gan':
            gan_config['model'].update({
                'input_dim': model_config.get('input_dim', 784),
                'training_algorithm': model_config.get('training_algorithm', 'backprop'),
                'generator_layers': model_config.get('generator_layers', [256, 512, 1024]),
                'discriminator_layers': model_config.get('discriminator_layers', [1024, 512, 256])
            })
        
        gan_config['metadata'].update({
            'built_at': time.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'build_step': 'completed'
        })
        
        # Create model info
        model_info_data = {
            'model_type': model_type,
            'model_name': args.model_name,
            'build_status': 'success',
            'config': model_config,
            'model_class': type(model).__name__
        }
        
        if model_type == 'vanilla_gan':
            model_info_data.update({
                'training_algorithm': model.config.training_algorithm.value,
                'generator_type': type(model.generator).__name__,
                'discriminator_type': type(model.discriminator).__name__,
                'trainer_type': type(model.trainer).__name__,
                'device': str(model.trainer.device),
                'input_dim': model.config.input_dim,
                'latent_dim': model.config.latent_dim
            })
        
        # Encode updated config to base64
        updated_config_json = json.dumps(gan_config)
        updated_config_base64 = base64.b64encode(updated_config_json.encode('utf-8')).decode('utf-8')
        
        # Save outputs
        os.makedirs(os.path.dirname(args.model_out) or '.', exist_ok=True)
        with open(args.model_out, 'wb') as f:
            pickle.dump(model, f)
        
        os.makedirs(os.path.dirname(args.gan_config_base64_updated) or '.', exist_ok=True)
        with open(args.gan_config_base64_updated, 'w') as f:
            f.write(updated_config_base64)
        
        os.makedirs(os.path.dirname(args.model_info) or '.', exist_ok=True)
        with open(args.model_info, 'w') as f:
            json.dump(model_info_data, f, indent=2)
        
        print("="*60)
        print("GAN Model Builder completed successfully")
        print(f"Model saved: {args.model_out}")
        print(f"Config (base64) saved: {args.gan_config_base64_updated}")
        print(f"Model info saved: {args.model_info}")
        print("="*60)

    args:
      - --gan_config_base64
      - {inputPath: gan_config_base64}
      - --model_name
      - {inputValue: model_name}
      - --model_out
      - {outputPath: model_out}
      - --gan_config_base64_updated
      - {outputPath: gan_config_base64_updated}
      - --model_info
      - {outputPath: model_info}
